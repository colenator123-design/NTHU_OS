同時存取共享資料可能導致資料不一致。

維護資料一致性需要機制來確保合作進程的有序執行。

當多個進程同時存取共享資料時，由於並行執行的特性，進程之間的執行順序是不確定的，這可能導致資料不一致。例如，當一個進程正在修改共享資料時，另一個進程可能讀取到部分更新的資料或過期的資料，從而導致資料錯誤或不完整。

為了確保資料的一致性，需要使用相應的機制來保證協作進程的有序執行。這些機制包括進程同步和互斥存取控制。進程同步機制用於控制進程之間的相對執行順序，例如使用信號量、條件變數、互斥鎖等。互斥存取控制機制用於確保同時只有一個進程可以存取共享資料，例如使用互斥鎖、讀寫鎖、臨界區等。通過這些機制，可以確保進程按照特定的順序和規則存取共享資料，從而維護資料的一致性。
生產者和消費者問題是一個經典的同步問題，涉及到多個進程（或執行緒）之間共享緩衝區的存取。

在這個例子中，存在一個緩衝區（buffer），生產者將物品放入緩衝區，消費者從緩衝區中取出物品。生產者和消費者可以並行運行，但需要確保下列條件：

當緩衝區為空時，消費者需要等待直到有物品可供取出。
當緩衝區已滿時，生產者需要等待直到有空間可供放入物品。
為了實現這個同步，使用了一個共享的計數器（counter）來追踪緩衝區中的物品數量。當counter為0時，表示緩衝區為空，消費者必須等待。當counter等於緩衝區的大小（BUFFER_SIZE）時，表示緩衝區已滿，生產者必須等待。

在消費者的程式碼中，首先檢查counter是否為0，如果是，表示緩衝區為空，無法取出物品，進入等待狀態。如果counter不為0，表示有物品可供取出，從緩衝區中取出物品（使用in和out位置）。然後，更新in位置和counter。

在生產者的程式碼中，首先獲取下一個物品（getItem()），然後檢查counter是否等於BUFFER_SIZE，如果是，表示緩衝區已滿，無法放入物品，進入等待狀態。如果counter小於BUFFER_SIZE，表示有空間可供放入物品，將物品放入緩衝區（使用in和out位置）。然後，更新out位置和counter。

通過這種方式，生產者和消費者之間實現了同步，確保了緩衝區的一致性和正確性。在適當的時候，生產者和消費者進入等待狀態，直到有滿足條件的事件發生。這種同步機制可以避免競爭條件和不一致的狀態，確保生產者和消費者之間的協調運作。

競爭條件（Race Condition）指的是多個進程同時訪問和操作共享數據的情況。最終共享數據的值取決於哪個進程最後完成。競爭條件可能導致結果的不確定性和不一致性。

為了防止競爭條件，需要對並發進程進行同步處理。在單處理器的機器上，可以禁用中斷或使用非抢占式的CPU調度，以確保同一時間只有一個進程能夠執行。在多處理器系統中，需要使用同步機制（如鎖、信號量等）來確保共享數據的安全訪問和操作。

競爭條件通常被描述為「臨界區問題」（Critical Section Problem），即多個進程在訪問共享數據的臨界區域時可能發生的問題。為了確保臨界區域的正確執行，需要使用同步機制來控制進程對共享數據的訪問，以避免競爭條件的發生。
臨界區問題（The Critical-Section Problem）的目的是為進程之間提供一個協作的協議。

問題描述如下：

N個進程競爭使用某些共享數據。
每個進程都有一段代碼，稱為臨界區（critical section），用於訪問共享數據。
確保當一個進程正在執行其臨界區時，不允許其他進程同時執行其臨界區，即互斥。
解決臨界區問題的關鍵在於設計一個合適的同步機制，以確保在任何給定的時間點只有一個進程能夠進入臨界區域。常見的同步機制包括鎖（Locks）、信號量（Semaphores）、條件變量（Condition Variables）等。

為了解決臨界區問題，需要滿足以下三個要求：

互斥性（Mutual Exclusion）：同一時間只能有一個進程進入臨界區域。
進程無預先假設（No Preemption）：進程在臨界區域內運行時不能被中斷或抢占。
有限等待（Bounded Waiting）：對於進入臨界區域的進程，必須有一個有限的等待時間，以確保其他進程有機會進入臨界區域。
通過設計適當的同步機制，解決臨界區問題可以實現進程間的合作，確保共享數據的安全訪問和操作，避免競爭條件的發生。
互斥性（Mutual Exclusion）：當進程P正在執行其臨界區（Critical Section，CS）時，其他進程不能同時執行其臨界區。

進展性（Progress）：如果沒有進程正在執行其臨界區，但存在一些希望進入臨界區的進程，這些進程不能無限期地被延遲。

有限等待（Bounded Waiting）：在一個進程發出進入臨界區的請求後，其他進程進入臨界區的次數必須受到限制。

為了滿足這些要求，需要設計適當的進入區域（Entry Section）和退出區域（Exit Section）。

兩個 Processes:以上的程式碼其實並不完美，這個程式要能順利運作的前提是，兩個 Process 必須輪流執行，但 while loop，並不保證執行的順序，很有可能 Process 0 執行完一次，又想進入 critical section，但 Process 1 還沒執行到 turn = 0 這一行，P0 就會卡在 while loop ，不符合 progress
Bakery Algorithm (n processes)
在進入 critical section 之前，每一個 Process 會抽號碼牌
號碼牌數字最小的先進入 critical section (注意可能有相同的號碼牌，如下方程式碼以 max 實作，而 max 指令其實有好幾行)
號碼牌數字的產生一定是 non-decreasing order; i.e. 1,2,3,3,4,5,5,5…
若兩個 Process Pi & Pj 有相同的號碼牌，則 PID 小的先進入
choosing[i] 為是否正在抽號碼牌的 flag，在與其他 Process j 比較之前，我們必須等待 Process j 抽完號碼牌。考慮一個狀況， Process j 比 i 晚抽完號碼牌，但號碼與 i 一樣大，又 j 的 PID 比 i 小，所以 Process j 應該要先執行 ; 如果在 j 還沒抽號碼牌之前就進行比較，此時 num[j] = 0，程式會以為 j 不要執行，反而先執行 i，當 j 抽完號碼牌之後發現數字與 i 相同，因此也可以進入 critical section，但這時 i 已經在裡頭，導致 deadlock
硬體支援解決方案是使用原子指令atomic instructions。原子指令是指作為一個不可中斷的單元執行的指令。例如，TestAndSet(var)和Swap(a,b)就是兩個常見的原子指令。這些指令能夠在單個操作中完成對共享變數的修改，確保在同一時間內只有一個進程可以存取該變數，從而達到臨界區的互斥性。這些原子指令通常由硬體提供支援，確保其操作是不可中斷的，從而解決了臨界區問題。
TestAndSet(var)操作本身並不滿足Bounded Waiting（有界等待）的要求。Bounded Waiting指的是在進程試圖進入其臨界區域時，其他進程不能無限期地推遲該進程的進入。然而，使用TestAndSet(var)操作時，如果某個進程一直在等待該變數的值變為特定值（例如0），但是其他進程不斷地修改該變數的值，則這個進程可能會一直等待下去，無法進入臨界區域。
TestAndSet(var)操作在一個忙等待（spinlock）的機制下工作，進程會不斷檢查變數的值，直到成功為止。如果其他進程一直在修改該變數的值，則等待的進程可能會被無限期地推遲。這種無限期的等待可能會導致Bounded Waiting的要求無法滿足。

為了滿足Bounded Waiting的要求，需要使用更複雜的同步機制，例如信號量（semaphore）或互斥鎖（mutex），它們可以提供更精細的控制和調度機制，以確保進程的公平性和有界等待。這些機制可以在進程無法進入臨界區域時，使其進入等待狀態，並確保在一定時間內其他進程也有機會進入臨界區域，從而避免了無限期的等待情況。
Spinlock實現：

信號量是一個整數變量
等待操作（wait）的實現：
當S的值小於等於0時，進程會進入一個循環中，不斷檢查S的值，直到其大於0為止。然後，進程將S的值減1。

信號操作（signal）的實現：
進程將S的值加1。

當進程需要訪問受信號量保護的共享資源時，它首先執行等待操作（wait）以檢查信號量的數值。如果數值表示資源已被佔用，則進程進入等待狀態，直到其他進程發出信號操作（signal）來釋放資源。當資源可用時，進程執行等待操作（wait）以將信號量的數值減少，表示它正在使用該資源。

信號量是實現同步和互斥的重要機制，它可以用於解決多個進程或執行緒之間的競爭條件和共享資源的訪問問題。通過適當的使用和調度信號量，可以確保進程按照特定的順序訪問共享資源，並避免競爭和不一致性的問題。

Pthread Lock/Mutex Routines（Pthread鎖/互斥鎖例程）用於保護關鍵區域（Critical Section），確保在同一時間只有一個執行緒可以訪問該區域。以下是對Pthread Lock/Mutex Routines的中文解釋：

要使用互斥鎖（mutex），必須將其聲明為pthread_mutex_t類型，並使用pthread_mutex_init()進行初始化。
可以使用pthread_mutex_destroy()來銷毀互斥鎖。
可以使用pthread_mutex_lock()和pthread_mutex_unlock()來保護關鍵區域。
範例程式碼中，首先使用pthread_mutex_init()初始化互斥鎖，然後使用pthread_mutex_lock()進入關鍵區域，執行關鍵代碼，並使用pthread_mutex_unlock()離開關鍵區域。最後，使用pthread_mutex_destroy()銷毀互斥鎖。
互斥鎖提供了一個安全的機制，確保在多個執行緒中同步訪問共享資源。通過在關鍵區域的進入和退出處使用互斥鎖，我們可以確保每次只有一個執行緒可以訪問該區域，從而防止競爭條件和資源衝突的問題。
Condition Variables（條件變數）是一種表示某些條件的機制，讓執行緒可以等待該條件發生，或通知其他等待的執行緒該條件已經發生。

在條件變數上有三個操作：

wait()：阻塞執行緒，直到另一個執行緒呼叫了該條件變數的signal()或broadcast()。
signal()：喚醒一個等待在條件變數上的執行緒。
broadcast()：喚醒所有等待在條件變數上的執行緒。
在Pthread中，條件變數的類型是pthread_cond_t。我們可以使用pthread_cond_init()進行初始化，使用pthread_cond_wait()在條件變數上等待（需搭配某個鎖），使用pthread_cond_signal()喚醒一個等待的執行緒，使用pthread_cond_broadcast()喚醒所有等待的執行緒。

條件變數提供了一個在多執行緒環境下同步的機制，允許執行緒們等待特定條件的發生，並進行相應的操作。通過條件變數的等待和通知操作，我們可以更靈活地控制執行緒之間的執行順序和互動。
Semaphore（信號量）是一種用於通用化同步問題的工具，它更容易解決問題，但不能保證正確性。

具體來說，

信號量紀錄特定資源可用的單位數量

如果紀錄的數值為1，則稱為二進制信號量（binary semaphore）或互斥鎖（mutex lock）
如果紀錄的數值大於1，則稱為計數信號量（counting semaphore）
信號量只能通過兩個原子操作來訪問：等待（wait）和信號（signal）
原子操作是指在執行過程中不會被中斷的操作，它要麼完全執行，要麼完全不執行，沒有中間狀態。原子操作確保了在多個執行緒或處理器間的並行執行中，操作不會被其他操作中斷或干擾。

在單處理器系統中，可以通過禁止中斷來確保原子等待和信號操作。禁止中斷可以確保一個操作的執行過程中不會被其他中斷事件干擾，從而保證了操作的原子性。

然而，在多處理器系統中，禁止中斷不再是一個可行的解決方案。相反，需要硬體或軟體支持來實現原子操作。硬體支持包括提供原子指令（例如Test-And-Set、Swap）的處理器。這些指令允許在執行過程中對共享變量進行原子操作，從而確保操作的完整性和一致性。

此外，還有軟體解決方案，如Peterson's解法和Bakery算法。這些算法使用特殊的同步機制和變量，在多個執行緒之間實現原子操作，從而達到同步和保護共享資源的目的。

總結而言，原子操作是在執行過程中不會被中斷的操作，可以通過硬體支持（如原子指令）或軟體解決方案（如特殊算法）來確保操作的完整性和一致性。它們是實現多執行緒同步和保護共享資源的重要概念和工具。
死結（Deadlocks）是指兩個或多個進程在等待對方釋放資源的情況下無限期地阻塞的狀態。當每個進程都持有一個資源並且同時等待其他進程所持有的資源時，就可能發生死結。這種情況下，沒有任何進程能夠繼續執行，它們都被阻塞在等待對方釋放資源的狀態，形成了一個死結。

死結的產生通常涉及四個必要條件，稱為死結條件（Deadlock Conditions）：

互斥條件（Mutual Exclusion）：至少一個資源同一時間只能被一個進程持有。
佔有並等待條件（Hold and Wait）：進程持有至少一個資源且在等待獲得其他進程持有的資源。
沒有抢占條件（No Preemption）：資源只能在持有進程願意釋放時才能被釋放，其他進程無法強制抢佔。
循環等待條件（Circular Wait）：一系列進程形成一個循環，每個進程都在等待下一個進程所持有的資源。
另一方面，飢餓（Starvation）是指某個進程或資源在系統中長時間無法獲得所需資源的情況。飢餓可能發生在資源分配不公平或者某些進程持續獲得資源的情況下。例如，使用LIFO（後進先出）佇列的信號量進程佇列中，某些進程可能會一直被新到的進程所擠壓，無法獲得資源並繼續執行。

死結和飢餓都是多進程系統中可能出現的問題，它們可能導致系統無法正常運作，進程無法順利執行，或者資源無法被充分利用。因此，在設計和實現系統時，需要考慮和解決這些問題，確保資源分配和進程執行的順利進行。
