Preemptive Issues 是指抢占式调度在多线程编程中带来的问题。

首先，抢占式调度可能会导致共享数据的不一致状态。在多线程程序中，不同的线程可能会同时访问同一份共享数据，如果线程之间没有进行同步操作，就会出现数据不一致的情况。为了避免这种情况，需要使用进程同步的方法，比如互斥锁、信号量等，但这些同步操作会增加访问共享数据的开销。

其次，抢占式调度也会影响操作系统内核的设计。如果在进行一些关键操作，比如 I/O 队列的修改时，线程被抢占了，那么内核或者设备驱动程序就需要访问或修改同一份数据结构，这就可能导致不一致状态的出现。为了解决这个问题，Unix 系统采用了禁用中断的方法，在等待系统调用或者 I/O 阻塞之前，先禁用中断来防止抢占。
Dispatcher module（調度程序）將CPU控制權交給由調度程序選擇的進程，以實現上下文切換（context switch）和跳轉到選定程序的正確位置。
Dispatcher module需要完成調度時間（scheduling time）、中斷重新啟用時間（interrupt re-enabling time）和上下文切換時間（context switch time）等操作，這些時間加起來就是調度延遲（dispatch latency）。
Scheduling Criteria（排程標準）：

CPU利用率、吞吐量、周轉時間、等待時間、響應時間。

CPU utilization：表示系統的CPU使用情況，理論上為0%到100%，實際上較為常見的是40%（輕負載）到90%（重負載）之間。
Throughput：表示單位時間內完成的進程數量。
Turnaround time：表示一個進程從提交到完成所需的時間。
Waiting time：表示進程在ready queue中等待的總時間。
Response time：表示提交一個進程後，系統產生第一個響應所需的時間。
FCFS (First-Come-First-Serve) Scheduling是一種作業系統的進程排程演算法，它將先到達系統的進程先執行，直到完成或被阻塞，才會執行下一個進程。

舉例來說，假設系統有三個進程 P1、P2、P3，其執行時間分別為 24、3、3 單位時間，FCFS 排程會先執行 P1，再執行 P2 和 P3。

FCFS 排程可能會出現 Convoy effect(護衛效應) 的現象，即長時間執行的進程會阻塞其他短進程的執行，進而導致整體的執行效率下降。在上述例子中，進程 P1 的執行時間較長，會導致進程 P2 和 P3 的等待時間增加。因此，在實際應用中，需要根據不同情況選擇適合的進程排程演算法，以提高系統的執行效率。
最短作業優先（SJF）排程

為每個進程關聯其下一個 CPU 執行時間的長度
擁有最短執行時間的進程優先獲得 CPU
SJF 提供最小平均等待時間（最優！）
兩種方式：
非抢占式 - 一旦 CPU 分配給一個進程，它直到完成才能被抢占
抢占式 - 如果有一個新的進程到達，其執行時間更短，則會發生抢占
SJF的困難之處在於無法預知下一個CPU執行週期的長度。
以先前CPU執行週期的平均值來預測下一個執行週期的長度，並以此來進行優先級調度，就是Approximate SJF。
Priority Scheduling 是一種根據優先級分配 CPU 資源的演算法。每個進程都被賦予一個優先級數字，而 CPU 資源會分配給具有最高優先級的進程。此演算法可分為兩種類型：可抢佔式和不可抢佔式。當然，最短作業優先 (SJF) 也是一種優先級調度，其中優先級是預測下一個 CPU 執行時間。 但 Priority Scheduling 也存在問題：低優先級的進程有可能一直得不到執行，稱之為饑餓現象。為了解決這個問題，可實現aging機制，隨著時間的推移增加進程的優先級。例如，每15分鐘增加1個優先級。
Round-Robin (RR) 調度

每個進程都獲得一小段 CPU 時間（時間量子），通常是 10 到 100 毫秒
當時間量子 TQ 過去後，進程被抢占並添加到就緒隊列的末尾
性能
TQ 較大時，會近似先進先出（FCFS）
TQ 較小時，上下文切換開銷增加

Multilevel Queue Scheduling（多層佇列排程）的解釋：

 Ready queue（就緒佇列）被分成不同的佇列
 每個佇列都有自己的排程演算法
 排程必須在不同佇列之間進行
 固定優先權排程：有可能會發生餓死（starvation）
 時間片（time slice）：每個佇列獲得一定的 CPU 時間（例如 80%、20
 Multilevel Feedback Queue Scheduling（多級反饋佇列排程）是一種將作業排成多個佇列的排程演算法，讓進程依照其運行狀況進行不同的優先級調整。較高優先級的佇列先被執行，防止進程饑餓（即低優先級進程一直無法執行），並且可以實現老化（aging）以避免進程饑餓。例如，可以將進程根據它們的CPU burst特性分為不同的佇列以模擬SJF，減少平均等待時間。具體而言，I/O-bound和互動型進程放在較高優先級的佇列中，因為這些進程具有較短的CPU burst時間，而CPU-bound進程放在較低優先級的佇列中，因為這些進程具有較長的CPU burst時間。
 多層反饋佇列調度器（Multilevel Feedback Queue Scheduler）通常由以下參數定義：

佇列數目
每個佇列的調度演算法
確定何時將進程升級的方法
確定何時將進程降級的方法。
Evaluation Methods ：

 確定性建模（Deterministic modeling）- 採用特定的預先決定工作量，定義每個算法在該工作量下的性能，但無法推廣至其他情境。
 排隊模型（Queueing model）- 數學分析法。
 模擬（Simulation）- 使用隨機數生成器或追蹤磁帶生成工作負載。
 實作（Implementation）- 算法評估的唯一完全準確的方法。
多處理器排程

 非對稱式多處理器：
- 所有系統活動都由一個處理器處理（減輕了數據共享的需要）
- 其他處理器只執行用戶端程式碼（由主控處理器分配）
- 比對稱式多處理器簡單得多
對稱式多處理器（SMP）：
- 每個處理器都是自我調度的
- 所有共用就緒隊列的流程，或者每個流程都有自己的私有就緒隊列
- 需要同步機制
「處理器關聯性」(affinity)指的是一個進程對當前正在運行的處理器有一定的偏好。進程會將其最近使用的數據放入處理器緩存內，當進程切換到另一個處理器時，需要清空該處理器的緩存並重新填充新的數據，這樣會帶來高昂的成本。

為解決此問題，可以採用「軟關聯性」或「硬關聯性」。軟關聯性表示進程可以在不同處理器之間移動，而硬關聯性表示進程不能切換到其他處理器上運行。
NUMA（非均勻記憶體訪問）：

出現在包含結合的 CPU 和記憶體板的系統中。
CPU 調度器和記憶體放置一起工作。
一個進程（分配給某個 CPU 的親和性）可以在該 CPU 所在的板上分配內存。
在 NUMA 系統中，記憶體的訪問時間取決於進程所在的 CPU 和進程要訪問的記憶體位置之間的距離。進程可能更喜歡訪問與其所在 CPU 相關聯的記憶體，因為這樣可以減少存取時間。因此，CPU 調度器通常會儘可能地將進程調度到與其所在 CPU 相關聯的記憶體板上運行，以提高整體性能。
Load balancing（負載平衡）是指在多處理器系統中，保持工作負載均勻分配到所有處理器上的一種方法。這種方法僅在每個處理器都有自己的可執行進程的私有佇列的系統中才是必要的。

通常有兩種策略：Push migration（推式遷移）和Pull migration（拉式遷移）。Push migration（推式遷移）是將負載過重的進程從一個處理器移到空閒或負載較輕的處理器上。Pull migration（拉式遷移）是當一個空閒的處理器需要一個進程時，會將等待的進程從忙碌的處理器上拉過來。

負載平衡通常會抵消處理器親和性的好處。

多核處理器（Multi-core Processor）是一種中央處理器（CPU）設計，其內部包含多個處理核心（Processing Core），每個核心都可以執行一個或多個獨立的處理任務。相比單核心處理器，多核處理器可以同時處理更多的任務，從而提高計算效率。此外，由於每個核心可以獨立運行，多核處理器也可以更有效地控制能耗，從而降低系統功耗和散熱需求。

在使用多核處理器時，有時會遇到“內存停頓”（Memory Stall）問題。當處理器需要訪問內存中的數據時，如果數據不在高速緩存（Cache）中，就需要花費大量時間等待數據讀取完成。這種等待的時間會導致處理器浪費大量的計算資源，從而影響整個系統的效率。

多線程多核系統（Multi-threaded multi-core systems）是一種利用多核處理器的方式。這種系統通常會將兩個或多個硬件線程（Hardware Thread）分配給每個處理核心，以實現更高的運算效率。在進行內存訪問時，如果遇到內存停頓問題，系統會利用這段等待時間來進行其他線程的處理，從而最大化地利用處理核心的計算能力。例如，英特爾的超線程技術（Hyper-threading）就可以讓每個處理核心同時執行兩個線程，從而提高系統的整體效率。
兩種多線程處理器的方式：

粗粒度（coarse-grained）：當出現內存阻塞時切換到另一個線程。這樣做的代價很高，因為指令管道必須被清空。
細粒度（fine-grained）（交替執行）：在指令週期邊界之間在線程之間切換。架構設計包括線程切換的邏輯，代價較低。
在多線程多核系統中進行調度：

第一級：選擇要在每個硬件線程（邏輯處理器）上運行的軟件線程。
第二級：每個核心決定運行哪個硬件線程。
實時調度（Real-time Scheduling）是指在限制時間內完成工作的調度，而非單純的速度優化。實時系統需要考慮時間約束，確保工作能夠按照預定的期限完成。

在實時系統中，軟實時要求是指錯過期限是不可取的，但不會立即導致系統故障，例如多媒體流媒體。而硬實時要求則表示錯過期限將導致系統崩潰或出現嚴重的故障，例如核電廠控制器。實時調度需要根據不同工作的時限、優先級以及其他約束條件來進行調度，以保證任務能夠按照時限完成
Real-Time Scheduling Algorithms 中文翻譯

FCFS 排程算法 - 非實時系統
 T1 = (0, 4, 10) == (就緒, 執行, 周期)
 T2 = (1, 2, 4)
 Rate-Monotonic (RM) 算法
 周期越短，優先級越高
 固定優先級的實時系統排程算法
 Earliest-Deadline-First (EDF) 算法
 期限越早，優先級越高
 動態優先級算法
 
 
優先級多層反饋隊列調度法

優先級多層反饋隊列調度法是一種將多種調度策略相結合的調度方法。該方法將進程分為不同的優先級隊列，每個隊列都有自己的調度算法和時間配額，並且每個進程都會根據其性質和優先級被分配到適當的隊列中。當進程運行時，其優先級會根據調度算法的結果進行動態調整，以確保高優先級進程能夠及時地運行，從而達到更好的性能和響應時間。

優先級多層反饋隊列調度法支持六種進程類型，包括實時進程、系統進程、時間共享進程、交互式進程、公平共享進程和固定優先級進程。每種類型的進程都有自己的優先級範圍和調度算法，而調度器將進程根據其類型和優先級劃分到對應的隊列中。進程在不同的隊列中運行，當其運行時間超過時間配額時，就會被降級到下一個優先級隊列中，這樣可以防止高優先級進程長時間佔用CPU資源，提高CPU利用率和整體性能。
Solaris调度器示例（时间共享，交互式）

Solaris是一种使用时间片轮转调度算法的操作系统。它使用多级反馈队列调度算法来支持六个不同的调度类别，包括实时、系统、时间共享、交互式、公平分享和固定优先级。

在时间共享和交互式类别中，Solaris调度器会根据线程的优先级为其分配时间片。优先级越高的线程获得的时间片越小，以保证高优先级线程优先执行。当一个线程使用完了它的整个时间片而没有被阻塞时，调度器会将其新的优先级设置为更高的值。当一个线程从睡眠状态（例如I/O等待）返回时，调度器会将其新的优先级设置为较低的值，以便其他需要更高优先级的线程优先执行。
