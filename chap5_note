Preemptive Issues 是指抢占式调度在多线程编程中带来的问题。

首先，抢占式调度可能会导致共享数据的不一致状态。在多线程程序中，不同的线程可能会同时访问同一份共享数据，如果线程之间没有进行同步操作，就会出现数据不一致的情况。为了避免这种情况，需要使用进程同步的方法，比如互斥锁、信号量等，但这些同步操作会增加访问共享数据的开销。

其次，抢占式调度也会影响操作系统内核的设计。如果在进行一些关键操作，比如 I/O 队列的修改时，线程被抢占了，那么内核或者设备驱动程序就需要访问或修改同一份数据结构，这就可能导致不一致状态的出现。为了解决这个问题，Unix 系统采用了禁用中断的方法，在等待系统调用或者 I/O 阻塞之前，先禁用中断来防止抢占。
Dispatcher module（調度程序）將CPU控制權交給由調度程序選擇的進程，以實現上下文切換（context switch）和跳轉到選定程序的正確位置。
Dispatcher module需要完成調度時間（scheduling time）、中斷重新啟用時間（interrupt re-enabling time）和上下文切換時間（context switch time）等操作，這些時間加起來就是調度延遲（dispatch latency）。
Scheduling Criteria（排程標準）：

CPU利用率、吞吐量、周轉時間、等待時間、響應時間。

CPU utilization：表示系統的CPU使用情況，理論上為0%到100%，實際上較為常見的是40%（輕負載）到90%（重負載）之間。
Throughput：表示單位時間內完成的進程數量。
Turnaround time：表示一個進程從提交到完成所需的時間。
Waiting time：表示進程在ready queue中等待的總時間。
Response time：表示提交一個進程後，系統產生第一個響應所需的時間。
FCFS (First-Come-First-Serve) Scheduling是一種作業系統的進程排程演算法，它將先到達系統的進程先執行，直到完成或被阻塞，才會執行下一個進程。

舉例來說，假設系統有三個進程 P1、P2、P3，其執行時間分別為 24、3、3 單位時間，FCFS 排程會先執行 P1，再執行 P2 和 P3。

FCFS 排程可能會出現 Convoy effect(護衛效應) 的現象，即長時間執行的進程會阻塞其他短進程的執行，進而導致整體的執行效率下降。在上述例子中，進程 P1 的執行時間較長，會導致進程 P2 和 P3 的等待時間增加。因此，在實際應用中，需要根據不同情況選擇適合的進程排程演算法，以提高系統的執行效率。
最短作業優先（SJF）排程

為每個進程關聯其下一個 CPU 執行時間的長度
擁有最短執行時間的進程優先獲得 CPU
SJF 提供最小平均等待時間（最優！）
兩種方式：
非抢占式 - 一旦 CPU 分配給一個進程，它直到完成才能被抢占
抢占式 - 如果有一個新的進程到達，其執行時間更短，則會發生抢占
SJF的困難之處在於無法預知下一個CPU執行週期的長度。
以先前CPU執行週期的平均值來預測下一個執行週期的長度，並以此來進行優先級調度，就是Approximate SJF。
Priority Scheduling 是一種根據優先級分配 CPU 資源的演算法。每個進程都被賦予一個優先級數字，而 CPU 資源會分配給具有最高優先級的進程。此演算法可分為兩種類型：可抢佔式和不可抢佔式。當然，最短作業優先 (SJF) 也是一種優先級調度，其中優先級是預測下一個 CPU 執行時間。 但 Priority Scheduling 也存在問題：低優先級的進程有可能一直得不到執行，稱之為饑餓現象。為了解決這個問題，可實現aging機制，隨著時間的推移增加進程的優先級。例如，每15分鐘增加1個優先級。
Round-Robin (RR) 調度

每個進程都獲得一小段 CPU 時間（時間量子），通常是 10 到 100 毫秒
當時間量子 TQ 過去後，進程被抢占並添加到就緒隊列的末尾
性能
TQ 較大時，會近似先進先出（FCFS）
TQ 較小時，上下文切換開銷增加

Multilevel Queue Scheduling（多層佇列排程）的解釋：

 Ready queue（就緒佇列）被分成不同的佇列
 每個佇列都有自己的排程演算法
 排程必須在不同佇列之間進行
 固定優先權排程：有可能會發生餓死（starvation）
 時間片（time slice）：每個佇列獲得一定的 CPU 時間（例如 80%、20
 Multilevel Feedback Queue Scheduling（多級反饋佇列排程）是一種將作業排成多個佇列的排程演算法，讓進程依照其運行狀況進行不同的優先級調整。較高優先級的佇列先被執行，防止進程饑餓（即低優先級進程一直無法執行），並且可以實現老化（aging）以避免進程饑餓。例如，可以將進程根據它們的CPU burst特性分為不同的佇列以模擬SJF，減少平均等待時間。具體而言，I/O-bound和互動型進程放在較高優先級的佇列中，因為這些進程具有較短的CPU burst時間，而CPU-bound進程放在較低優先級的佇列中，因為這些進程具有較長的CPU burst時間。
 多層反饋佇列調度器（Multilevel Feedback Queue Scheduler）通常由以下參數定義：

佇列數目
每個佇列的調度演算法
確定何時將進程升級的方法
確定何時將進程降級的方法。
Evaluation Methods ：

 確定性建模（Deterministic modeling）- 採用特定的預先決定工作量，定義每個算法在該工作量下的性能，但無法推廣至其他情境。
 排隊模型（Queueing model）- 數學分析法。
 模擬（Simulation）- 使用隨機數生成器或追蹤磁帶生成工作負載。
 實作（Implementation）- 算法評估的唯一完全準確的方法。
多處理器排程

 非對稱式多處理器：
- 所有系統活動都由一個處理器處理（減輕了數據共享的需要）
- 其他處理器只執行用戶端程式碼（由主控處理器分配）
- 比對稱式多處理器簡單得多
對稱式多處理器（SMP）：
- 每個處理器都是自我調度的
- 所有共用就緒隊列的流程，或者每個流程都有自己的私有就緒隊列
- 需要同步機制
「處理器關聯性」(affinity)指的是一個進程對當前正在運行的處理器有一定的偏好。進程會將其最近使用的數據放入處理器緩存內，當進程切換到另一個處理器時，需要清空該處理器的緩存並重新填充新的數據，這樣會帶來高昂的成本。

為解決此問題，可以採用「軟關聯性」或「硬關聯性」。軟關聯性表示進程可以在不同處理器之間移動，而硬關聯性表示進程不能切換到其他處理器上運行。
NUMA（非均勻記憶體訪問）：

出現在包含結合的 CPU 和記憶體板的系統中。
CPU 調度器和記憶體放置一起工作。
一個進程（分配給某個 CPU 的親和性）可以在該 CPU 所在的板上分配內存。
在 NUMA 系統中，記憶體的訪問時間取決於進程所在的 CPU 和進程要訪問的記憶體位置之間的距離。進程可能更喜歡訪問與其所在 CPU 相關聯的記憶體，因為這樣可以減少存取時間。因此，CPU 調度器通常會儘可能地將進程調度到與其所在 CPU 相關聯的記憶體板上運行，以提高整體性能。
Load balancing（負載平衡）是指在多處理器系統中，保持工作負載均勻分配到所有處理器上的一種方法。這種方法僅在每個處理器都有自己的可執行進程的私有佇列的系統中才是必要的。

通常有兩種策略：Push migration（推式遷移）和Pull migration（拉式遷移）。Push migration（推式遷移）是將負載過重的進程從一個處理器移到空閒或負載較輕的處理器上。Pull migration（拉式遷移）是當一個空閒的處理器需要一個進程時，會將等待的進程從忙碌的處理器上拉過來。

負載平衡通常會抵消處理器親和性的好處。
