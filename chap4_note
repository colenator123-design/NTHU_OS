4.2: Under what circumstances does a multithreaded
solution using multiple kernel threads provide better

performance than a single-threaded solution on a single-
processor system?

 4.3: Which of the following components of program state
are shared across threads in a multithreaded process?
a. Register values; b. Heap memory; c. Global variables;
d. Stack memory

解答4.2：
在單核系統上，多線程解決方案比單線程解決方案更快的情況主要取決於程序中存在並行性的程度。如果程序中有許多並行性任務，那麼多線程解決方案將更快，因為它可以在同一時間處理多個任務，而單線程解決方案只能依次處理這些任務。

然而，如果程序中沒有太多的並行性，那麼多線程解決方案可能不會更快，因為創建和管理線程需要額外的開銷，並且在單核系統上並不能同時執行多個線程。

解答4.3：
在多線程進程中，寄存器值和堆內存通常是線程私有的，而全局變量和堆外內存（例如靜態變量和程序代碼）是線程共享的。堆內存也可以被標記為共享的，以允許線程之間共享數據。栈內存對於每個線程都是私有的，並且不能在線程之間共享。

Pthread Joining & Detaching

Pthread Joining和Detaching是POSIX線程庫（Pthreads）中的兩種操作。

Pthread Joining是一種等待線程執行完畢的操作。當一個線程被創建時，它可以通過pthread_join()函數加入到主線程中，當主線程調用pthread_join()函數時，它會等待指定的線程執行完畢。當被等待的線程執行完畢後，主線程才會繼續執行。這樣可以保證線程間的同步，並且可以獲取線程的返回值。

Pthread Detaching是一種將線程和主線程解除關聯的操作。當一個線程被創建時，它可以通過pthread_detach()函數與主線程分離，這樣當線程執行完畢後，它的資源會被自動釋放，而不需要等待主線程調用pthread_join()函數。這種方式通常用於那些不需要獲取線程返回值的線程，例如後台線程或者守護進程。

Pthread Joining和Detaching都是線程之間進行同步的重要機制。它們可以保證線程的執行順序，並且可以避免線程之間的競爭條件和死鎖問題。Pthreads庫提供了一個強大而靈活的線程管理機制，開發者可以根據實際需要選擇使用不同的線程操作。

在clone()系統調用中，使用一組標誌（flags）指示共享級別。如果這些標誌中沒有設置任何一個，那麼clone()將與fork()的行為相同。如果所有標誌都被設置，那麼父進程和子進程將共享所有資源，包括內存、文件描述符、信號處理程序、定時器、資源限制等。

execlp()是一個在Linux/Unix系統上的C語言標准庫函數，它可以在當前進程上執行指定的可執行文件。在執行期間，當前進程的內容將被新程序替換，新程序將開始運行。

線程取消是一種機制，用於在多線程編程中中止執行中的線程。當一個線程取消時，它可能已經執行了一部分，但仍然需要停止它的執行，以避免對整個應用程序的功能造成損害。

線程取消的實現方式可以分為兩種類型：異步取消和延遲取消。異步取消是指一個線程突然終止另一個線程的執行，這種方式可能會造成資源泄漏或數據一致性問題，因此不太安全。延遲取消是指一個線程定期檢查自己是否被取消，如果是，則採取適當的操作安全地終止自己。

當線程取消時，可以指定一些處理程序，以確保執行的程序能夠在安全的條件下停止。這些處理程序稱為取消點，通常是一些標準庫函數，例如pthread_join()和pthread_cond_wait()。當線程在取消點上阻塞時，它會等待其他線程通知它是否應該繼續執行。當一個線程被取消時，如果它正在等待一個取消點，它會在取消點上被取消，否則它會繼續執行，直到自己到達一個取消點或者執行完畢。

線程取消是一個複雜的問題，需要仔細考慮。如果不適當地使用，可能會導致資源泄漏、數據一致性問題和內存錯誤等問題。因此，在使用線程取消時，需要仔細設計和測試程式碼，以確保它在任何情況下都能正確地執行。
在 UNIX 系統中，訊號（synchronous 或 asynchronous）用於通知進程發生了某個事件。同步訊號通常是由於不合法的記憶體訪問等異常情況觸發，而非同步訊號則通常是由用戶交互事件，例如 Ctrl-C 信號，觸發的。

當一個進程收到一個訊號時，需要對其進行處理，以便進程可以在事件發生後採取適當的操作。這個處理過程稱為訊號處理。在 UNIX 系統中，可以設置一個訊號處理函數（signal handler），用於處理訊號。當訊號發生時，系統將調用設置的處理函數，以執行相應的處理。

訊號處理的實現方式比較靈活，可以選擇將訊號發送到特定的線程或進程中，也可以將訊號發送到整個進程或特定的線程組中。對於多線程應用程序，需要考慮訊號處理對於不同線程的影響，避免訊號處理導致資源競爭或死鎖等問題。

總之，訊號處理是 UNIX 系統中一個重要的概念，用於處理進程中的異常情況和用戶交互事件。通過設置訊號處理函數，可以實現對於不同事件的處理，並確保系統在事件發生後可以繼續正常運行。
Thread pool是一种线程管理技术，它预先创建一组固定数量的线程，并让它们等待工作。当有工作需要处理时，线程池中的某个线程会被分配并处理工作。当一个线程完成了一个任务，它会返回线程池，等待下一个任务。使用线程池技术，可以在应用程序中维护一组可用的线程，这样就不需要在需要处理请求时创建新的线程。

线程池的优点有：

创建新线程比较耗费系统资源，因为需要为每个线程分配内存，初始化线程环境等等。线程池通过预先创建线程，可以减少创建线程的数量，提高程序的性能。

线程池可以限制线程的数量。如果应用程序需要处理大量的请求，那么为每个请求创建一个新线程可能会耗尽系统资源，甚至导致系统崩溃。线程池通过限制线程的数量，可以避免这种情况发生。

线程池可以提高响应速度。当有新的请求到达时，线程池中的线程可以立即开始处理请求，而不需要等待新线程的创建和初始化。这可以提高应用程序的响应速度。

线程池的线程数应该根据系统资源的情况来确定。通常情况下，可以将线程数设置为与CPU数量相同的值，这样可以充分利用系统资源，避免出现过多的线程导致系统性能下降的情况。另外，线程池的大小也可以根据应用程序需要处理的请求数量和可用的物理内存大小来确定。
Thread Specific Data（簡稱TSD）是一種機制，允許每個執行緒擁有自己的數據副本，不同執行緒之間可以使用相同的代碼，但又可以存取自己的數據。這個機制對於一些特定的應用情境非常有用，例如在事務處理系統中，每個事務可以被指定一個唯一的編號。TSD機制也常用於使用執行緒池的情況，當我們無法控制執行緒的創建過程時，可以使用TSD來管理執行緒專屬的數據。

Scheduler Activations是一種維持多線程應用程式正確的執行的技術，它可以透過通訊機制，使應用程式和作業系統之間能夠適當地分配資源和調度。它在M:M和Two-level模型中都有應用。

在Scheduler Activations中，作業系統會發送一個稱為upcall的訊息到執行緒庫，請求它在特定線程上執行任務。當這個訊息被接收時，執行緒庫就會將該線程從閒置隊列中取出，執行由作業系統所要求的任務。這樣可以有效地減少在多線程應用程式中所需的上下文切換次數，提高了應用程式的效率和性能。

Scheduler Activations的一個主要優勢是可以適應不同的硬體和軟體環境，可以在不同的作業系統和處理器上使用。此外，它也能夠適應不同類型的應用程式，從高併發性的伺服器應用程式到圖形使用者介面應用程式都可以使用Scheduler Activations。


